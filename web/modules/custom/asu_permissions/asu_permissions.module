<?php

/**
 * @file
 * Contains asu_permissions.module.
 */

use Drupal\Core\Access\AccessResultNeutral;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\group\Entity\Group;
use Drupal\group\Entity\GroupContent;
use Drupal\node\NodeInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Messenger\MessengerInterface;
use Drupal\Core\Access\AccessResult;
use Drupal\user\UserInterface;
use Drupal\Core\Access\AccessResultForbidden;
use GuzzleHttp\Exception\ClientException;
use GuzzleHttp\Exception\ConnectException;
use Drupal\asu_permissions\Exception\LibauthException;
use Drupal\Core\Entity\EntityStorageException;
use Drupal\Core\Render\RenderContext;
use Drupal\group\Access\CalculatedGroupPermissionsItemInterface as CGPII;

define('GNODE_MASTER_GRANT_ID', 1986);


/**
 * Implements hook_node_insert().
 *
 * Alternatively could trigger this with a context reaction.
 */
function asu_permissions_node_insert(NodeInterface $node) {
  if ($node->bundle() == "collection") {
    // Create a new group for the collection.
    $pluginId = 'group_node:' . $node->bundle();
    $col_group = Group::create(['type' => 'collection_group', 'label' => 'Collection ' . $node->id() . ' Group']);
    $col_group->save();
    $col_group->addContent($node, $pluginId);
    $col_group->save();
  }
  elseif ($node->bundle() == 'asu_repository_item') {
    // Add the asu_repository_item to the parent collection's group.
    // We are assumming here one member_of relationship.
    $parent = _get_collection_parent($node);
    if ($parent) {
      $pluginId = 'group_node:' . $node->bundle();
      $group_contents = _get_group($parent);
      if (!empty($group_contents)) {
        foreach ($group_contents as $group_content) {
          /** @var \Drupal\group\Entity\GroupContentInterface $group_content */
          $group = $group_content->getGroup();
          $group->addContent($node, $pluginId);
        }
      }
    }
  }
}

/**
 * Gets the collection parent of an entity.
 */
function _get_collection_parent($entity) {
  $parent = $entity->field_member_of->entity;
  if ($parent) {
    if ($parent->bundle() != "collection") {
      $parent = _get_collection_parent($parent);
    }
    return $parent;
  }
}

/**
 * Gets the groups that an entity belongs to.
 */
function _get_group($entity) {
  $group_contents = \Drupal::entityTypeManager()
    ->getStorage('group_content')
    ->loadByEntity($entity);
  return $group_contents;
}

/**
 * Removes an entity from a collection group.
 */
function _remove_object_from_parent_group($entity, $parent) {
  $group_contents = _get_group($entity);
  if (empty($group_contents)) {
    return;
  }
  foreach ($group_contents as $group_content) {
    /** @var \Drupal\group\Entity\GroupContentInterface $group_content */
    $group = $group_content->getGroup();
    if ($group->label() == 'Collection ' . $parent->id() . ' Group') {
      $group_content->delete();
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function asu_permissions_node_delete(NodeInterface $node) {
  if ($node->bundle() == "collection") {
    // Delete the collection group.
    $group_contents = _get_group($node);
    if (empty($group_contents)) {
      return;
    }
    foreach ($group_contents as $group_content) {
      /** @var \Drupal\group\Entity\GroupContentInterface $group_content */
      $group = $group_content->getGroup();
      $group->delete();
    }
  }
  elseif ($node->bundle() == 'asu_repository_item') {
    $parent = _get_collection_parent($node);
    if ($parent) {
      _remove_object_from_parent_group($node, $parent);
    }
  }
}

/**
 * Add object to group.
 */
function _add_object_to_parent_group($node) {
  $pluginId = 'group_node:' . $node->bundle();
  $group_contents = _get_group($node->get('field_member_of')->entity);

  // Check if the node is already in the group.
  $node_group_contents = _get_group($node);
  if (!empty($node_group_contents)) {
    foreach ($node_group_contents as $gc) {
      $group = $gc->getGroup();
      if ($group->label() == 'Collection ' . $node->get('field_member_of')->entity->id() . ' Group') {
        return;
      }
    }
  }

  if (!empty($group_contents)) {
    foreach ($group_contents as $group_content) {
      /** @var \Drupal\group\Entity\GroupContentInterface $group_content */
      $group = $group_content->getGroup();
      $group->addContent($node, $pluginId);
    }
  }
}

/**
 * Implements hook_node_update().
 */
function asu_permissions_node_update(NodeInterface $node) {
  if ($node != NULL && $node->bundle() == 'asu_repository_item') {
    $utils = \Drupal::service('islandora.utils');
    if (!$utils->haveFieldsChanged($node, $node->original)) {
      return;
    }
    if ($node->get('field_member_of')->entity && $node->original->get('field_member_of')->entity) {
      if ($node->get('field_member_of')->entity->id() != $node->original->get('field_member_of')->entity->id()) {
        _remove_object_from_parent_group($node, $node->original->get('field_member_of')->entity);
        _add_object_to_parent_group($node);
      }
    }
    elseif (!$node->get('field_member_of')->entity && $node->original->get('field_member_of')->entity) {
      _remove_object_from_parent_group($node, $node->original->get('field_member_of')->entity);
    }
    elseif ($node->get('field_member_of')->entity && !$node->original->get('field_member_of')->entity) {
      _add_object_to_parent_group($node);
    }

    $of_items = $node
      ->get('field_default_original_file_perm')
      ->filterEmptyItems();
    $of_original_items = $node->original
      ->get('field_default_original_file_perm')
      ->filterEmptyItems();

    // If the field items are not equal, we need to save.
    if (!$of_items->equals($of_original_items)) {
      // change the media with type OF
      $medias = $utils->getMedia($node);
      foreach($medias as $media) {
        $term = $media->get('field_media_use')->entity;
        $term_name = $term->getName();
        if ($term_name == "Original File") {
          $media->set('field_access_terms', $node
            ->get('field_default_original_file_perm')->entity->id());
          $media->save();
        }
      }
    }

    $df_items = $node
      ->get('field_default_derivative_file_pe')
      ->filterEmptyItems();
    $df_original_items = $node->original
      ->get('field_default_derivative_file_pe')
      ->filterEmptyItems();

    // If the field items are not equal, we need to save.
    if (!$df_items->equals($df_original_items)) {
      // change the media with service file
      if (!isset($medias)) {
        $medias = $utils->getMedia($node);
      }
      foreach ($medias as $media) {
        $term = $media->get('field_media_use')->entity;
        $term_name = $term->getName();
        if ($term_name == "Service File") {
          $media->set('field_access_terms', $node
            ->get('field_default_derivative_file_pe')->entity->id());
          $media->save();
        }
      }
    }
  }
}

/**
 * Implements hook_node_access().
 */
function asu_permissions_node_access(NodeInterface $node, $op, AccountInterface $account) {
//   // \Drupal::logger('asu permissions')->info("access check for " . $node->id() . " which is a " . $node->bundle());
  if ($node->bundle() == "collection" || $node->bundle() == "asu_repository_item") {
    $plugin_id = 'group_node:' . $node->bundle();

    $parents = _walk_membership($node, []);
    foreach ($parents as $par) {
      if ($par->bundle() == 'collection') {
        if ($par->get('field_enabled') && $par->get('field_enabled')->value == 0) {
          $access_result = AccessResult::forbiddenIf(!($account->isAuthenticated() && !in_array("administrator", $account->getRoles())));
          break;
        }
        else {
          // \Drupal::logger('asu permissions')->info($par->id() . " is enabled.");
        }
      }
    }
    // \Drupal::logger('asu permissions - access before group')->info($access_result);

    $groups = _get_groups_from_node($node);
    // If the node does not belong to any group, we have nothing to say.
    if (empty($groups) && !(isset($access_result))) {
      $access_result = AccessResult::neutral();
    }
    // if the node is published and there is parent access, don't bother checking the groups
    if ($node->isPublished()) {
      if (count($parents) > 0) {
        foreach ($parents as $par) {
          if ($par->uuid() != $node->uuid()) {
            // This line enforces if you can't view a parent then you can't view child.
            $taccess = $par->access('view', $account);
            if (isset($access_result) && $access_result instanceof AccessResultForbidden) {
              // Already forbidden.
            } else {
              $access_result = AccessResult::forbiddenIf($taccess == FALSE);
            }
          }
        }
      } else {
        $access_result = AccessResult::allowed();
      }
    }
    if (!isset($access_result)) {
      // From this point on you need group to allow you to perform the operation.
      if ($op == 'view' || $op == 'update') {
        foreach ($groups as $group) {
          if ($node->isPublished()) {
            if ($group->hasPermission("view $plugin_id entity", $account) && $group->getMember($account)) {
              if (count($parents) > 0) {
                foreach ($parents as $par) {
                  if ($par->uuid() != $node->uuid()) {
                    // This line enforces if you can't view a parent then you can't view child.
                    $taccess = $par->access('view', $account);
                    if (isset($access_result) && $access_result instanceof AccessResultForbidden) {
                      // Already forbidden.
                    }
                    else {
                      $access_result = AccessResult::forbiddenIf($taccess == FALSE);
                    }
                  }
                }
              }
              else {
                $access_result = AccessResult::allowed();
              }
            }
            else {
              if (count($parents) > 0) {
                foreach ($parents as $par) {
                  if ($par->uuid() != $node->uuid()) {
                    // This line enforces if you can't view a parent then you can't view child.
                    $taccess = $par->access('view', $account);
                    if (isset($access_result) && $access_result instanceof AccessResultForbidden) {
                      // Already forbidden.
                    } else {
                      $access_result = AccessResult::forbiddenIf($taccess == FALSE);
                    }
                  }
                }
              } else {
                $access_result = AccessResult::allowed();
              }
            }
          }
          elseif ($group->hasPermission("view unpublished $plugin_id entity", $account) && $group->getMember($account)) {
            // This is what gives metadata managers and admins their power.
            $access_result = AccessResult::allowed();
          }
          else {
            // Forbid if not explictly allowed by group. This is powerful.
            $access_result = AccessResult::forbidden();
          }
        }
      }
    }
  }
  if (isset($access_result)) {
    $access_result->addCacheableDependency($node);
    $access_result->addCacheContexts(['theme']);
    return $access_result;
  }
  else {
    return AccessResult::neutral();
  }
}

/**
 * Implements hook_media_access().
 *
 * Which is also hook_entity_type_access().
 */
function asu_permissions_media_access(EntityInterface $entity, $operation, AccountInterface $account) {
  $item = $entity->get('field_media_of')->entity;
  if (!$item) {
    // Return neutral because it isn't an Islandora media - it isn't attached to an item.
    return new AccessResultNeutral();
  }
  if ($account->isAuthenticated() && (in_array("administrator", $account->getRoles()) || in_array("metadata_manager", $account->getRoles()))) {
    // Allow if admin.
    // TODO potentially do a lookup here for additional all-seeing roles.
    $access_result = AccessResult::allowed();
  }
  // \Drupal::logger('asu permissions')->info("checking access for " . $entity->get('field_media_use')->entity->getName());
  if ($entity->hasField('field_access_terms') && $entity->get('field_access_terms')->entity) {
    // \Drupal::messenger()->addMessage("has islandora access set");
    $access_term = $entity->get('field_access_terms')->entity->getName();
  }
  else {
    // Assume its public if not access is set.
    $access_term = "Public";
  }
  // \Drupal::logger('asu permissions')->info("access term: " . $access_term);
  if (!$account->isAuthenticated() && $access_term != "Public") {
    $access_result = AccessResult::forbidden();
    // \Drupal::logger('asu permissions')->info('access results: forbidden');
  }
  // \Drupal::logger('asu permissions')->info('access results' . $access_result);
  if (!isset($access_result)) {
    // \Drupal::logger('asu permissions')->info('had to go deeper because it was public');
    // Depend on the permission of the parent item
    $taccess = $item->access($operation, $account);
    $all_parents = _walk_membership($item, [$item]);
    foreach ($all_parents as $par) {
      $date = new \DateTime();
      $today = $date->format("c");
      if ($par->hasField('field_embargo_release_date') && $par->get('field_embargo_release_date') && $par->get('field_embargo_release_date')->value >= $today) {
        $access_term = "Private";
        $taccess = 0;
      }
    }
    // \Drupal::logger('asu permissions')->info("parent access: " . $taccess);
    if ($taccess == 1) {

      if ($account->isAuthenticated() && $access_term == "Private") {
        $access_result = AccessResult::forbidden();
        $groups = _get_groups_from_node($item);
        foreach ($groups as $g) {
          if ($g->getMember($account)) {
            $access_result = AccessResult::allowed();
            break;
          }
        }
      }
      else {
        // \Drupal::logger('asu permissions')->info("not authenticated or not Private");
        if ($access_term == "Public") {
          $access_result = AccessResult::forbiddenIf($taccess == 0);
        }
      }
    }
    else {
      // \Drupal::logger('asu permissions')->info("access is not 1");
      $access_result = AccessResult::forbiddenIf($taccess == 0);
    }

  }
  if (isset($access_result)) {
    $access_result->addCacheableDependency($entity);
    $access_result->addCacheableDependency($account);
    $access_result->addCacheContexts(['theme']);
    return $access_result;
  }
  else {
    return AccessResult::neutral();
  }

}

/**
 * Follows chain of field_member_of links.
 */
function _walk_membership(NodeInterface $entity, $parents) {
  $enarr = [];
  $enarr[] = $entity;

  // Find the next in the chain, if there are any.
  if ($entity->hasField('field_member_of') &&
    !$entity->get('field_member_of')->isEmpty() && $entity->get('field_member_of') != NULL && $entity->get('field_member_of')->referencedEntities() != NULL) {
    $newent = $entity->get('field_member_of')->referencedEntities()[0];
    if (!array_key_exists($newent->id(), $parents)) {
      $parents[$newent->id()] = $newent;
    }
    $new_pars = _walk_membership($newent, $parents);
  }
  if (isset($new_pars)) {
    return array_merge_recursive_unique($parents, $new_pars);
  }
  else {
    $newarr = array_merge_recursive_unique($parents, $enarr);
    return $newarr;
  }
}

function array_merge_recursive_unique($array1, $array2) {
  if (empty($array1)) return $array2; //optimize the base case

  foreach ($array2 as $key => $value) {
    if (is_array($value) && is_array(@$array1[$key])) {
      $value = array_merge_recursive_unique($array1[$key], $value);
    }
    $array1[$key] = $value;
  }
  return $array1;
}

/**
 * Implements hook_file_download.
 */
function asu_permissions_file_download($uri) {
  // @todo
  /* @var \Drupal\file\FileInterface[] $files */
  $files = \Drupal::entityTypeManager()
    ->getStorage('file')
    ->loadByProperties(['uri' => $uri]);
  foreach ($files as $f) {
    $utils = \Drupal::service('islandora.utils');
    $medias = $utils->getReferencingMedia($f->id());
    if (count($medias) == 0) {
      return NULL;
    }
    foreach ($medias as $mid => $media) {
      // $node = $utils->getParentNode($media);
      $user = \Drupal::currentUser();
      if (!$media->access('view', $user)) {
        // if (!$node->access('view')) {
        // If the user isn't allowed to view the media, return -1 to tell
        // Drupal to block access to the file currently being requested.
        return -1;
      }
    }
  }
}

/**
 * Get the groups for a node.
 */
function _get_groups_from_node(EntityInterface $node) {
  // Load all of the group content for this node.
  $group_contents = \Drupal::entityTypeManager()
    ->getStorage('group_content')
    ->loadByEntity($node);

  /** @var \Drupal\group\Entity\GroupInterface[] $groups */
  $groups = [];
  foreach ($group_contents as $group_content) {
    /** @var \Drupal\group\Entity\GroupContentInterface $group_content */
    $group = $group_content->getGroup();
    $groups[$group->id()] = $group;
  }
  return $groups;
}

/**
 * Implements hook_entity_type_insert().
 * Implements hook_user_insert().
 */
function asu_permissions_user_insert(UserInterface $entity) {
  $url = "http://authprod.lib.asu.edu/asurite/" . $entity->getDisplayName() . ".json";
  $client = \Drupal::httpClient();
  $roles = $entity->getRoles();
  // if they aren't going to be a casuser, then we can just proceed without this check
  if (!(in_array('casuser', $entity->getRoles()))) {
    return;
  }
  try {
    // try checking if they are in the headcount in authprod/libauth
    $request = $client->request('GET', $url);
    if ($request->getStatusCode() == 200) {
      // if 200 and in headcount, proceed
      $json = json_decode($request->getBody(), TRUE);
      if (array_key_exists('in_headcount', $json) && $json['in_headcount'] == TRUE) {
        $fname = $json['person']['preferred_first_name'] != '' ? $json['person']['preferred_first_name'] : $json['person']['first_name'];
        $lname = $json['person']['preferred_last_name'] != '' ? $json['person']['preferred_last_name'] : $json['person']['last_name'];
        $honors = $json['honors'];
        $emplid = $json['person']['emplid'];
        $schools = [];
        $entity->set('field_first_name', $fname);
        $entity->set('field_last_name', $lname);
        $entity->set('field_honors', $honors);
        $entity->set('field_emplid', $emplid);
        if ($honors) {
          $entity->addRole('honors_student');
          foreach ($json['stuplan'] as $plan) {
            if (!in_array($plan['acad_dept_org_descr'],$schools)) {
              array_push($schools, $plan['acad_dept_org_descr']);
            }
            if ($plan['acad_career'] == 'UGRD') {
              $campus = $plan['campus'];
            }
          }
        }
        $entity->set('field_programs', $schools);
        if (!$campus) {
          $campus = $json['stuplan'][0]['campus'];
        }
        $entity->set('field_campus', $campus);
        $entity->save();
      }
      else {
        throw new LibauthException('Libauth: User is not authorized for electronic resources at ASU. If you think this is an error, <a href="/contact">please contact us</a>.');
      }
    } else if ($request->getStatusCode() == 404) {
      // if 404 exit without creating user
      throw new LibauthException('Libauth: Unable to find user ' . $entity->getDisplayName() . ' at ASU. If you think this is an error, <a href="/contact">please contact us</a>.');

    } else {
      throw new LibauthException('Libauth: There was an issue validating user ' . $entity->getDisplayName() . ' at ASU due to a non-standard status code (not 200 or 404. If you think this is an error, <a href="/contact">please contact us</a>.');
      // if anything else exit without creating user

    }
  }
  catch (EntityStorageException $e) {
    throw new LibauthException('Libauth: User is not authorized for electronic resources at ASU. If you think this is an error, <a href="/contact">please contact us</a>.');
  }
  catch (ClientException $e) {
    if ($request && $request->getStatusCode() == 404) {
      throw new LibauthException('Libauth: Unable to find user ' . $entity->getDisplayName() . ' at ASU. If you think this is an error, <a href="/contact">please contact us</a>.');

    } else {
        throw new LibauthException('Libauth: There was an issue validating user ' . $entity->getDisplayName() . ' at ASU due to a client exception. If you think this is an error, <a href="/contact">please contact us</a>.');
    }
  }
  catch (ConnectException $e) {
    throw new LibauthException('Libauth: There was an issue validating user ' . $entity->getDisplayName() . ' at ASU due to a connection exception. If you think this is an error, <a href="/contact">please contact us</a>.');
  }
}

/**
 * Implements hook_theme().
 */
function asu_permissions_theme() {
  return [
    'exception_template' => [
      'template' => 'custom-exception',
      'variables' => [
        'message' => NULL,
      ]
    ],
  ];
}

/**
 * Implements hook_node_grants().
 *
 * We define the following grants:
 * - 'gnode:NODE_TYPE': Grants view and update or delete any access to nodes.
 * - 'gnode_unpublished:NODE_TYPE': Grants view access to unpublished nodes.
 * - 'gnode_author:UID:NODE_TYPE': Grants update or delete access to authors.
 * - 'gnode_anonymous': Given to anonymous users.
 * - 'gnode_bypass': Given to anyone with the 'bypass group access' permission.
 *
 * @see gnode_node_access_records()
 */
// function asu_permissions_node_grants(AccountInterface $account, $op) {
//   // Provide the master grant for users who can bypass group access.
//   if ($account->hasPermission('bypass group access')) {
//     return ['gnode_bypass' => [GNODE_MASTER_GRANT_ID]];
//   }

//   // Anonymous users get the anonymous grant. See the implementation in the
//   // gnode_node_access_records() function as to why that is.
//   if ($account->isAnonymous()) {
//     return ['gnode_anonymous' => [GNODE_MASTER_GRANT_ID]];
//   }

//   // Gather the machine names of all node types.
//   $entity_type_manager = \Drupal::entityTypeManager();
//   $node_type_ids = $entity_type_manager
//     ->getStorage('node_type')
//     ->getQuery()
//     ->execute();

//   /** @var \Drupal\group\Access\ChainGroupPermissionCalculatorInterface $permission_calculator */
//   $permission_calculator = \Drupal::service('group_permission.chain_calculator');
//   $calculated_permissions = $permission_calculator->calculatePermissions($account);

//   // Initialize an array for group-specific and group type-wide permissions.
//   $grants_group = $grants_group_type = [];

//   // First set grants for permissions that the user has in specific groups.
//   foreach ($calculated_permissions->getItemsByScope(CGPII::SCOPE_GROUP) as $item) {
//     // Add the groups the user is a member of to use later on.
//     $member_gids[] = $gid = $item->getIdentifier();

//     foreach ($node_type_ids as $node_type_id) {
//       $plugin_id = "group_node:$node_type_id";

//       switch ($op) {
//         case 'view':
//           if ($item->hasPermission("view $plugin_id entity", $account)) {
//             $grants_group["gnode:$node_type_id"][] = $gid;
//           }
//           if ($item->hasPermission("view unpublished $plugin_id entity", $account)) {
//             $grants_group["gnode_unpublished:$node_type_id"][] = $gid;
//           }
//           break;

//         case 'update':
//         case 'delete':
//           // If you can act on any node, there's no need for the author grant.
//           if ($item->hasPermission("$op any $plugin_id entity", $account)) {
//             $grants_group["gnode:$node_type_id"][] = $gid;
//           }
//           elseif ($item->hasPermission("$op own $plugin_id entity", $account)) {
//             $uid = $account->id();
//             $grants_group["gnode_author:$uid:$node_type_id"][] = $gid;
//           }
//           break;
//       }
//     }
//   }

//   // Then add grants for permissions that the user has for all groups of a type.
//   /** @var \Drupal\group\Entity\GroupTypeInterface[] $group_types */
//   $group_types = $entity_type_manager->getStorage('group_type')->loadMultiple();
//   foreach ($calculated_permissions->getItemsByScope(CGPII::SCOPE_GROUP_TYPE) as $item) {
//     // Get the IDs of all the groups the user is not part of for the group type.
//     $query = $entity_type_manager->getStorage('group')->getQuery();
//     $query->condition('type', $item->getIdentifier());
//     if (!empty($member_gids)) {
//       $query->condition('id', $member_gids, 'NOT IN');
//     }
//     $gids = \Drupal::service('renderer')->executeInRenderContext(new RenderContext(), function () use ($query) {
//       return $query->execute();
//     });

//     // If we could not retrieve any group IDs, skip to the next group type.
//     if (empty($gids)) {
//       continue;
//     }

//     foreach ($node_type_ids as $node_type_id) {
//       $plugin_id = "group_node:$node_type_id";

//       // Only check for permissions if the group type has the group_node plugin
//       // installed for the node type.
//       if (!$group_types[$item->getIdentifier()]->hasContentPlugin($plugin_id)) {
//         continue;
//       }

//       switch ($op) {
//         case 'view':
//           if ($item->hasPermission("view $plugin_id entity")) {
//             $grants_group_type["gnode:$node_type_id"][] = $gids;
//           }
//           if ($item->hasPermission("view unpublished $plugin_id entity")) {
//             $grants_group_type["gnode_unpublished:$node_type_id"][] = $gids;
//           }
//           break;

//         case 'update':
//         case 'delete':
//           // If you can act on any node, there's no need for the author grant.
//           if ($item->hasPermission("$op any $plugin_id entity")) {
//             $grants_group_type["gnode:$node_type_id"][] = $gids;
//           }
//           elseif ($item->hasPermission("$op own $plugin_id entity")) {
//             $uid = $account->id();
//             $grants_group_type["gnode_author:$uid:$node_type_id"][] = $gids;
//           }
//           break;
//       }
//     }
//   }

//   // The code above populated the outsider grants by adding the group IDs per
//   // group type. We need to combine this into one big list of group IDs per
//   // entry in the $grants_o array.
//   foreach ($grants_group_type as $key => $gids_per_group_type) {
//     $grants_group_type[$key] = array_reduce($gids_per_group_type, 'array_merge', []);
//   }

//   // Recursively merge the member grants with the outsider grants.
//   return array_merge_recursive($grants_group, $grants_group_type);
// }

/**
 * Implements hook_node_access_records().
 *
 * @see gnode_node_grants()
 */
// function asu_permissions_node_access_records(NodeInterface $node) {
//   $records = $group_types = [];
//   $node_type_id = $node->bundle();
//   $plugin_id = "group_node:$node_type_id";

//   // Load all of the group content for this node.
//   $group_contents = \Drupal::entityTypeManager()
//     ->getStorage('group_content')
//     ->loadByEntity($node);

//   // Only act if there are group content entities for this node.
//   if (empty($group_contents)) {
//     return $records;
//   }

//   // We can use the same grant-all base because we will only hand out the grants
//   // based on the $op parameter in hook_node_grants().
//   $base = [
//     'grant_view' => 1,
//     'grant_update' => 1,
//     'grant_delete' => 1,
//     'priority' => 0,
//   ];

//   // Set records for every group the node belongs to.
//   $uid = $node->getOwnerId();
//   $prefix = $node->isPublished() ? 'gnode' : 'gnode_unpublished';
//   foreach ($group_contents as $group_content) {
//     /** @var \Drupal\group\Entity\GroupContentInterface $group_content */
//     $group = $group_content->getGroup();
//     $group_type_id = $group_content->bundle();

//     // Gather all group types the node belongs to.
//     if (!isset($group_types[$group_type_id])) {
//       $group_types[$group_type_id] = $group->getGroupType();
//     }

//     // We use the group ID as the realm ID.
//     $gid = $group->id();
//     $records_exist = array_reduce(
//       $records,
//       function ($carry, $record) use ($gid, $node_type_id, $uid, $prefix) {
//         if ($record['gid'] != $gid) {
//           return $carry;
//         }
//         if ($record['realm'] === "$prefix:$node_type_id") {
//           $carry['non_author'] = TRUE;
//         } elseif ($record['realm'] === "gnode_author:$uid:$node_type_id") {
//           $carry['author'] = TRUE;
//         }

//         return $carry;
//       },
//       ['author' => FALSE, 'non_author' => FALSE]
//     );

//      // Add the non-author record for viewing nodes.
//     if (!$records_exist['non_author']) {
//       $records[] = [ 'gid' => $gid, 'realm' => "$prefix:$node_type_id" ] + $base;
//     }

//      // Add the author record for updating or deleting.
//     if (!$records_exist['author']) {
//       $records[] = [ 'gid' => $gid, 'realm' => "gnode_author:$uid:$node_type_id" ] + $base;
//     }
//   }

//   // Add the general access bypass record.
//   $records[] = ['gid' => GNODE_MASTER_GRANT_ID, 'realm' => 'gnode_bypass'] + $base;

//   // For anonymous users we actually build the access record based on the groups
//   // the node belongs to. After all: If you're anonymous to one group, you're
//   // anonymous to all groups. Meaning that if one of the node's groups allows
//   // anonymous users to view the node, all anonymous users can view it. We can
//   // use this to our advantage by assigning a special access record that we can
//   // provide a grant for in gnode_node_grants().
//   $anonymous_record = [
//     'gid' => GNODE_MASTER_GRANT_ID,
//     'realm' => 'gnode_anonymous',
//     'grant_view' => 0,
//     'grant_update' => 0,
//     'grant_delete' => 0,
//     'priority' => 0,
//   ];

//   // Get references to the grants for faster and more readable loops below.
//   $can_view = &$anonymous_record['grant_view'];
//   $can_update = &$anonymous_record['grant_update'];
//   $can_delete = &$anonymous_record['grant_delete'];

//   $view_permission = $node->isPublished()
//     ? "view $plugin_id entity"
//     : "view unpublished $plugin_id entity";

//   foreach ($group_types as $group_type) {
//     /** @var \Drupal\group\Entity\GroupTypeInterface $group_type */
//     $group_role = $group_type->getAnonymousRole();

//     if (!$can_view && $group_role->hasPermission($view_permission)) {
//       $can_view = 1;
//     }
//     if (!$can_update && $group_role->hasPermission("update any $plugin_id entity")) {
//       $can_update = 1;
//     }
//     if (!$can_delete && $group_role->hasPermission("delete any $plugin_id entity")) {
//       $can_delete = 1;
//     }

//     // If the node is owned by anonymous, we also need to check for the author
//     // permissions following the pattern "$op own $plugin_id entity".
//     if ($uid == 0) {
//       if (!$can_update && $group_role->hasPermission("update own $plugin_id entity")) {
//         $can_update = 1;
//       }
//       if (!$can_delete && $group_role->hasPermission("delete own $plugin_id entity")) {
//         $can_delete = 1;
//       }
//     }
//   }

//   $records[] = $anonymous_record;

//   return $records;
// }
