<?php

use Drupal\search_api\Entity\Index;

/**
 * @file
 * Contains asu_collection_extras.module.
 */

/**
 * This is used by the blocks in this module to get children of a collection.
 *
 * @param mixed $collection_node
 *   Can take a node object or the node ID value.
 * @param bool $sort_by_date
 *   (OPTIONAL) whether or not to sort by date, default is FALSE.
 * @param int $limit
 *   The number of results to return (to provide the recent additions for the
 *   block that only displays only 4 items)
 */
function asu_collection_extras_get_collection_children($collection_node, $sort_by_date = FALSE, $limit = 0, $items_only = TRUE) {
  $collection_nid = (is_object($collection_node) ? $collection_node->id() : $collection_node);
  $childrenQuery = \Drupal::entityQuery('node');
  $orGroup = $childrenQuery
    ->orConditionGroup()
    ->condition('field_member_of', $collection_nid)
    ->condition('field_additional_memberships', $collection_nid);
  $childrenQuery
    ->condition($orGroup)
    ->condition('status', 1);
  if ($items_only) {
    $childrenQuery
      ->condition('type', 'asu_repository_item');
  }
  if ($sort_by_date) {
    $childrenQuery
      ->sort('revision_timestamp', 'DESC');
  }
  if ($limit) {
    $childrenQuery
      ->range(0, $limit);
  }
  return $childrenQuery->execute();
}

/**
 * This is also used by the blocks in this module to get collection items.
 * 
 * The main difference between this and asu_collection_extras_get_collection_children
 * is that this will get all children in one go without having to recursively
 * call thanks to the ancestors field.
 *
 * @param mixed $collection_node
 *   Can take a node object or the node ID value.
 * @param bool $sort_by_date
 *   (OPTIONAL) whether or not to sort by date, default is FALSE.
 * @param int $limit
 *   The number of results to return (to provide the recent additions for the
 *   block that only displays only 4 items)
 *
 * @return array
 *   Multidimensional array that contains the nid, changed, and 
 * original_file_count for each child of the collection. The key of the top
 * array is the nid. This array should be sorted by the changed timestamps
 * so that the first element's changed value would be the most recent.
 */
function asu_collection_extras_solr_get_collection_children($collection_node) {
  $collection_node_id = (is_object($collection_node) ? $collection_node->id() : $collection_node);
  $nids_arr = [];
  if (!is_null($collection_node_id)) {
    $index = Index::load('default_solr_index');
    $server = $index->getServerInstance();
    $backend = $server->getBackend();
    $solrConnector = $backend->getSolrConnector();
    $solariumQuery = $solrConnector->getSelectQuery();
    // @todo Fix this so it loops through a reasonable amount of records
    // instead of setting a dangerously high value.
    $solariumQuery->setRows(2147483630);
    $solariumQuery->addParam('q', 'itm_field_ancestors:' . $collection_node_id);
    $solariumQuery->setFields(['its_nid', 'ds_changed', 'ss_original_file_count', 'itm_field_model']);
    $solariumQuery->addSort('ds_changed', 'desc');
    $nids = $solrConnector->execute($solariumQuery);
    foreach ($nids as $nid_doc) {
      $nids_arr[$nid_doc->its_nid] = [
        'changed' => $nid_doc->ds_changed,
        'original_file_count' => $nid_doc->ss_original_file_count,
        'field_model' => array_key_exists(0, $nid_doc->itm_field_model) ?
          $nid_doc->itm_field_model[0] : 0
      ]; 
    }
  }
  return $nids_arr;
}